/**
 * @fileoverview Servicio de Autenticaci√≥n Moderno con JWT + UUID
 *
 * Este servicio implementa un sistema de autenticaci√≥n completo con:
 * ‚úÖ JWT con JTI (UUID) para tracking √∫nico de tokens
 * ‚úÖ Gesti√≥n de sesiones activas en base de datos
 * ‚úÖ Bloqueo de cuentas por intentos fallidos
 * ‚úÖ Integraci√≥n con BaseService para consistencia
 * ‚úÖ Auditor√≠a completa de actividad de usuarios
 * ‚úÖ Extracci√≥n de id_ct_sesion desde JWT para bit√°cora
 *
 * üîê FLUJO DE AUTENTICACI√ìN:
 * 1. Usuario env√≠a credenciales
 * 2. Validar usuario y contrase√±a (bcrypt)
 * 3. Generar JWT con JTI √∫nico (UUID) e id_sesion
 * 4. Crear sesi√≥n en BD con informaci√≥n del dispositivo
 * 5. Retornar access token al cliente
 *
 * üîí FLUJO DE LOGOUT:
 * 1. Cliente env√≠a JWT v√°lido
 * 2. Marcar sesi√≥n como inactiva en BD
 * 3. JWT seguir√° siendo v√°lido hasta expiraci√≥n natural
 */

import jwt from "jsonwebtoken";
import bcrypt from "bcryptjs";
import { v4 as uuidv4 } from "uuid";
import { PrismaClient } from "@prisma/client";
import { BaseService } from "./BaseService";
import { jwtConfig, bcryptConfig } from "../config/env";
import {
  LoginInput,
  RefreshTokenInput,
  LogoutInput,
  RespuestaLogin,
  RespuestaRefresh,
  RespuestaLogout,
  UsuarioActual,
} from "../schemas/auth.schemas";

const prisma = new PrismaClient();

// ===== INTERFACES =====

/**
 * Payload del JWT con informaci√≥n esencial y JTI √∫nico
 */
interface PayloadJwt {
  sub: number; // ID del usuario (subject est√°ndar JWT)
  uuid: string; // UUID del usuario para identificaci√≥n alternativa
  usuario: string; // Nombre de usuario (no sensible)
  jti: string; // JWT ID √∫nico (UUID) para tracking
  iat: number; // Issued at (timestamp)
  exp: number; // Expiration (timestamp)
  iss: string; // Issuer (emisor)
}

/**
 * Informaci√≥n del dispositivo/cliente para auditor√≠a
 */
interface InfoDispositivo {
  ip: string;
  userAgent?: string;
  dispositivo?: string;
}

/**
 * Resultado interno de validaci√≥n de credenciales
 */
interface ValidacionCredenciales {
  valido: boolean;
  usuario?: any;
  motivo?: string;
  intentosFallidos?: number;
  bloqueadoHasta?: Date;
}

// ===== ERRORES PERSONALIZADOS =====

export class ErrorAuth extends Error {
  constructor(
    message: string,
    public codigo: string = "AUTH_ERROR",
    public statusCode: number = 401
  ) {
    super(message);
    this.name = "ErrorAuth";
  }
}

// ===== SERVICIO PRINCIPAL =====

export class AuthService {
  /**
   * üîê LOGIN DE USUARIO
   *
   * Proceso completo de autenticaci√≥n que incluye:
   * - Validaci√≥n de credenciales
   * - Control de intentos fallidos
   * - Generaci√≥n de tokens seguros
   * - Creaci√≥n de sesi√≥n activa
   * - Auditor√≠a de acceso
   */
  static async login(
    credenciales: LoginInput,
    infoDispositivo: InfoDispositivo
  ): Promise<RespuestaLogin> {
    try {
      // 1. üîç VALIDAR CREDENCIALES Y ESTADO DE CUENTA
      const validacion = await this.validarCredenciales(credenciales);

      if (!validacion.valido) {
        // Registrar intento fallido
        await this.registrarIntentoFallido(
          credenciales.usuario,
          infoDispositivo
        );

        throw new ErrorAuth(
          validacion.motivo || "Credenciales inv√°lidas",
          "CREDENCIALES_INVALIDAS",
          401
        );
      }

      const usuario = validacion.usuario;

      // 2. üÜî GENERAR JWT ID √öNICO
      const jti = uuidv4(); // JWT ID √∫nico

      // 3. üé´ GENERAR JWT CON JTI
      const payload: PayloadJwt = {
        sub: usuario.id_ct_usuario,
        uuid: usuario.uuid_usuario,
        usuario: usuario.usuario,
        jti,
        iat: Math.floor(Date.now() / 1000),
        exp:
          Math.floor(Date.now() / 1000) +
          this.parseTimeToSeconds(jwtConfig.expiresIn),
        iss: "infraestructura-system",
      };

      const accessToken = jwt.sign(payload, jwtConfig.secret, {
        algorithm: "HS256",
      });

      // 4. üóÑÔ∏è CREAR SESI√ìN EN BASE DE DATOS
      const fechaExpiracion = new Date(payload.exp * 1000);

      const sesion = await prisma.ct_sesion.create({
        data: {
          id_ct_usuario: usuario.id_ct_usuario,
          jti,
          ip_origen: infoDispositivo.ip,
          user_agent: infoDispositivo.userAgent,
          dispositivo: infoDispositivo.dispositivo || null,
          fecha_expiracion: fechaExpiracion,
          activa: true,
        },
      });

      // 5. ‚úÖ ACTUALIZAR ESTAD√çSTICAS DE USUARIO
      await prisma.ct_usuario.update({
        where: { id_ct_usuario: usuario.id_ct_usuario },
        data: {
          ultimo_login: new Date(),
          intentos_fallidos: 0, // Resetear intentos fallidos
          bloqueado_hasta: null, // Desbloquear cuenta si estaba bloqueada
        },
      });

      // 6. üìä PREPARAR RESPUESTA
      const respuesta: RespuestaLogin = {
        exito: true,
        mensaje: "Inicio de sesi√≥n exitoso",
        datos: {
          usuario: {
            id_ct_usuario: usuario.id_ct_usuario,
            uuid_usuario: usuario.uuid_usuario,
            usuario: usuario.usuario,
            email: usuario.email,
            ultimo_login: new Date(),
            fecha_registro: usuario.fecha_registro,
          },
          tokens: {
            accessToken,
            tipoToken: "Bearer",
            expiraEn: this.parseTimeToSeconds(jwtConfig.expiresIn),
          },
          sesion: {
            id_sesion: sesion.id_ct_sesion,
            jti,
            fecha_expiracion: fechaExpiracion,
            ip_origen: infoDispositivo.ip,
            dispositivo: infoDispositivo.dispositivo || null,
          },
        },
        meta: {
          tiempoRespuesta: Date.now(),
          version: "3.0.0", // Sin refresh tokens, solo JWT con sesiones
        },
      };

      return respuesta;
    } catch (error) {
      if (error instanceof ErrorAuth) {
        throw error;
      }

      console.error("‚ùå Error en login:", error);
      throw new ErrorAuth(
        "Error interno durante la autenticaci√≥n",
        "ERROR_INTERNO",
        500
      );
    }
  }

  /**
   * üîÑ REFRESH TOKEN
   *
   * Renueva el access token validando la sesi√≥n activa en BD
   * SIN usar tabla ct_refresh_token - solo valida JWT + sesi√≥n activa
   */
  static async refreshToken(
    input: RefreshTokenInput
  ): Promise<RespuestaRefresh> {
    try {
      // 1. üîç DECODIFICAR JWT (sin verificar expiraci√≥n)
      const decoded = jwt.decode(input.refreshToken) as PayloadJwt | null;

      if (!decoded || !decoded.jti) {
        throw new ErrorAuth(
          "Token inv√°lido o malformado",
          "TOKEN_INVALIDO",
          401
        );
      }

      // 2. ‚úÖ VERIFICAR QUE LA SESI√ìN SIGA ACTIVA EN BD
      const sesion = await prisma.ct_sesion.findUnique({
        where: { jti: decoded.jti },
        include: {
          ct_usuario: {
            select: {
              id_ct_usuario: true,
              uuid_usuario: true,
              usuario: true,
              email: true,
              estado: true,
              bloqueado_hasta: true,
            },
          },
        },
      });

      if (!sesion) {
        throw new ErrorAuth(
          "Sesi√≥n no encontrada o inv√°lida",
          "SESION_INVALIDA",
          401
        );
      }

      if (!sesion.activa) {
        throw new ErrorAuth(
          "Sesi√≥n inactiva. Debe iniciar sesi√≥n nuevamente.",
          "SESION_INACTIVA",
          401
        );
      }

      // 3. üë§ VERIFICAR ESTADO DEL USUARIO
      const usuario = sesion.ct_usuario;
      const ahora = new Date();

      if (!usuario.estado) {
        throw new ErrorAuth("Usuario inactivo", "USUARIO_INACTIVO", 401);
      }

      if (usuario.bloqueado_hasta && usuario.bloqueado_hasta > ahora) {
        throw new ErrorAuth(
          "Usuario temporalmente bloqueado",
          "USUARIO_BLOQUEADO",
          401
        );
      }

      // 4. üÜî GENERAR NUEVO JWT CON NUEVO JTI
      const nuevoJti = uuidv4();

      const payload: PayloadJwt = {
        sub: usuario.id_ct_usuario,
        uuid: usuario.uuid_usuario,
        usuario: usuario.usuario,
        jti: nuevoJti,
        iat: Math.floor(Date.now() / 1000),
        exp:
          Math.floor(Date.now() / 1000) +
          this.parseTimeToSeconds(jwtConfig.expiresIn),
        iss: "infraestructura-system",
      };

      const nuevoAccessToken = jwt.sign(payload, jwtConfig.secret, {
        algorithm: "HS256",
      });

      // 5. üîÑ ACTUALIZAR SESI√ìN CON NUEVO JTI
      await prisma.ct_sesion.update({
        where: { id_ct_sesion: sesion.id_ct_sesion },
        data: {
          jti: nuevoJti,
          fecha_ultimo_uso: new Date(),
          fecha_expiracion: new Date(payload.exp * 1000),
        },
      });

      // 6. üìä PREPARAR RESPUESTA
      const respuesta: RespuestaRefresh = {
        exito: true,
        mensaje: "Token renovado exitosamente",
        datos: {
          accessToken: nuevoAccessToken,
          refreshToken: nuevoAccessToken, // El mismo token sirve para refresh
          tipoToken: "Bearer",
          expiraEn: this.parseTimeToSeconds(jwtConfig.expiresIn),
          jti: nuevoJti,
        },
      };

      return respuesta;
    } catch (error) {
      if (error instanceof ErrorAuth) {
        throw error;
      }

      console.error("‚ùå Error en refresh token:", error);
      throw new ErrorAuth(
        "Error interno durante la renovaci√≥n del token",
        "ERROR_INTERNO",
        500
      );
    }
  }

  /**
   * üö™ LOGOUT DE USUARIO
   *
   * Termina sesi√≥n(es) activa(s)
   * Puede cerrar una sesi√≥n espec√≠fica o todas las sesiones del usuario
   */
  static async logout(
    input: LogoutInput,
    jtiActual: string
  ): Promise<RespuestaLogout> {
    try {
      // 1. üîç OBTENER INFORMACI√ìN DE LA SESI√ìN ACTUAL
      const sesionActual = await prisma.ct_sesion.findUnique({
        where: { jti: jtiActual },
        include: { ct_usuario: true },
      });

      if (!sesionActual) {
        throw new ErrorAuth("Sesi√≥n no encontrada", "SESION_INVALIDA", 401);
      }

      let sesionesTerminadas = 0;

      if (input.cerrarTodasLasSesiones) {
        // 2A. üî• LOGOUT GLOBAL - Cerrar todas las sesiones del usuario
        const sesionesResult = await prisma.ct_sesion.updateMany({
          where: {
            id_ct_usuario: sesionActual.id_ct_usuario,
            activa: true,
          },
          data: { activa: false },
        });

        sesionesTerminadas = sesionesResult.count;
      } else {
        // 2B. üéØ LOGOUT ESPEC√çFICO - Solo la sesi√≥n actual
        const sesionId = input.sesionId
          ? typeof input.sesionId === "string"
            ? parseInt(input.sesionId)
            : input.sesionId
          : sesionActual.id_ct_sesion;

        const sesionesResult = await prisma.ct_sesion.updateMany({
          where: {
            id_ct_sesion: sesionId,
            id_ct_usuario: sesionActual.id_ct_usuario,
            activa: true,
          },
          data: { activa: false },
        });

        sesionesTerminadas = sesionesResult.count;
      }

      // 3. üìä PREPARAR RESPUESTA
      const respuesta: RespuestaLogout = {
        exito: true,
        mensaje: input.cerrarTodasLasSesiones
          ? "Todas las sesiones han sido cerradas"
          : "Sesi√≥n cerrada exitosamente",
        datos: {
          sesionesTerminadas,
        },
      };

      return respuesta;
    } catch (error) {
      if (error instanceof ErrorAuth) {
        throw error;
      }

      console.error("‚ùå Error en logout:", error);
      throw new ErrorAuth(
        "Error interno durante el logout",
        "ERROR_INTERNO",
        500
      );
    }
  }

  /**
   * üë§ OBTENER USUARIO ACTUAL
   *
   * Retorna informaci√≥n del usuario autenticado y su sesi√≥n actual
   */
  static async obtenerUsuarioActual(jti: string): Promise<UsuarioActual> {
    try {
      const sesion = await prisma.ct_sesion.findUnique({
        where: { jti },
        include: {
          ct_usuario: {
            select: {
              id_ct_usuario: true,
              uuid_usuario: true,
              usuario: true,
              email: true,
              estado: true,
              ultimo_login: true,
              fecha_registro: true,
              fecha_modificacion: true,
            },
          },
        },
      });

      if (!sesion || !sesion.activa) {
        throw new ErrorAuth(
          "Sesi√≥n inv√°lida o expirada",
          "SESION_INVALIDA",
          401
        );
      }

      // Contar sesiones activas del usuario
      const sesionesActivas = await prisma.ct_sesion.count({
        where: {
          id_ct_usuario: sesion.id_ct_usuario,
          activa: true,
        },
      });

      const respuesta: UsuarioActual = {
        exito: true,
        mensaje: "Usuario obtenido exitosamente",
        datos: {
          usuario: sesion.ct_usuario,
          sesionActual: {
            id_sesion: sesion.id_ct_sesion,
            jti: sesion.jti,
            fecha_creacion: sesion.fecha_creacion,
            fecha_expiracion: sesion.fecha_expiracion,
            fecha_ultimo_uso: sesion.fecha_ultimo_uso,
            ip_origen: sesion.ip_origen,
            dispositivo: sesion.dispositivo,
          },
          estadisticasSesiones: {
            sesionesActivas,
            ultimaActividad: sesion.fecha_ultimo_uso,
          },
        },
      };

      return respuesta;
    } catch (error) {
      if (error instanceof ErrorAuth) {
        throw error;
      }

      console.error("‚ùå Error obteniendo usuario actual:", error);
      throw new ErrorAuth(
        "Error interno obteniendo informaci√≥n del usuario",
        "ERROR_INTERNO",
        500
      );
    }
  }

  // ===== M√âTODOS PRIVADOS =====

  /**
   * üîç VALIDAR CREDENCIALES
   *
   * Verifica usuario, contrase√±a y estado de la cuenta
   */
  private static async validarCredenciales(
    credenciales: LoginInput
  ): Promise<ValidacionCredenciales> {
    try {
      // Buscar usuario por nombre de usuario
      const usuario = await prisma.ct_usuario.findUnique({
        where: { usuario: credenciales.usuario },
      });

      if (!usuario) {
        return { valido: false, motivo: "Usuario no encontrado" };
      }

      // Verificar si la cuenta est√° bloqueada
      if (usuario.bloqueado_hasta && usuario.bloqueado_hasta > new Date()) {
        return {
          valido: false,
          motivo:
            "Cuenta temporalmente bloqueada por m√∫ltiples intentos fallidos",
          bloqueadoHasta: usuario.bloqueado_hasta,
        };
      }

      // Verificar si el usuario est√° activo
      if (!usuario.estado) {
        return { valido: false, motivo: "Cuenta de usuario inactiva" };
      }

      // Verificar contrase√±a
      const contrasenaValida = await bcrypt.compare(
        credenciales.contrasena,
        usuario.contrasena
      );

      if (!contrasenaValida) {
        return {
          valido: false,
          motivo: "Contrase√±a incorrecta",
          usuario,
          intentosFallidos: usuario.intentos_fallidos,
        };
      }

      return { valido: true, usuario };
    } catch (error) {
      console.error("‚ùå Error validando credenciales:", error);
      return { valido: false, motivo: "Error interno de validaci√≥n" };
    }
  }

  /**
   * üìä REGISTRAR INTENTO FALLIDO
   *
   * Incrementa contador de intentos fallidos y bloquea cuenta si es necesario
   */
  private static async registrarIntentoFallido(
    nombreUsuario: string,
    infoDispositivo: InfoDispositivo
  ): Promise<void> {
    try {
      const usuario = await prisma.ct_usuario.findUnique({
        where: { usuario: nombreUsuario },
      });

      if (!usuario) return; // No incrementar si el usuario no existe

      const nuevosIntentos = usuario.intentos_fallidos + 1;
      const LIMITE_INTENTOS = 5;
      const TIEMPO_BLOQUEO_MINUTOS = 30;

      let bloqueadoHasta: Date | null = null;

      if (nuevosIntentos >= LIMITE_INTENTOS) {
        bloqueadoHasta = new Date(
          Date.now() + TIEMPO_BLOQUEO_MINUTOS * 60 * 1000
        );
      }

      await prisma.ct_usuario.update({
        where: { id_ct_usuario: usuario.id_ct_usuario },
        data: {
          intentos_fallidos: nuevosIntentos,
          bloqueado_hasta: bloqueadoHasta,
        },
      });

      console.log(
        `‚ö†Ô∏è  Intento fallido registrado para usuario ${nombreUsuario} (${nuevosIntentos}/${LIMITE_INTENTOS}) desde IP ${infoDispositivo.ip}`
      );
    } catch (error) {
      console.error("‚ùå Error registrando intento fallido:", error);
    }
  }

  /**
   * ‚è±Ô∏è CONVERTIR TIEMPO A SEGUNDOS
   *
   * Convierte strings como "15m", "7d", "1h" a segundos
   */
  private static parseTimeToSeconds(timeStr: string): number {
    const regex = /^(\d+)([smhd])$/;
    const match = timeStr.match(regex);

    if (!match) {
      throw new Error(`Formato de tiempo inv√°lido: ${timeStr}`);
    }

    const [, amount, unit] = match;
    const num = parseInt(amount);

    switch (unit) {
      case "s":
        return num;
      case "m":
        return num * 60;
      case "h":
        return num * 60 * 60;
      case "d":
        return num * 24 * 60 * 60;
      default:
        throw new Error(`Unidad de tiempo no soportada: ${unit}`);
    }
  }
}

export default AuthService;
